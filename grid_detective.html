<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Grid Detective üïµÔ∏è‚Äç‚ôÇÔ∏è (User-Revealed Danger)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 18px; background: #0b1420; color: #e7eef8; }
    h1 { margin: 0 0 6px; font-size: 20px; }
    .muted { opacity:.8; font-size: 13px; line-height: 1.35; margin-bottom: 12px; }
    .card { background: #121f2f; border: 1px solid #1f3550; border-radius: 14px; padding: 14px; margin-bottom: 12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label { font-size: 13px; opacity:.9; }
    input[type="range"] { width: 220px; }
    button, select {
      padding: 10px; border-radius: 10px; border: 1px solid #284869;
      background: #0f1b2a; color: #e7eef8; cursor:pointer; font-size:14px;
    }
    button:hover { background:#132337; }
    .gridWrap { display:flex; justify-content:center; }
    .grid { display:grid; grid-template-columns: repeat(5, 68px); gap:10px; }
    .tile {
      width:68px; height:68px; border-radius: 16px; background:#22384f;
      display:flex; align-items:center; justify-content:center; user-select:none;
      cursor:pointer; position:relative; transition:.15s;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      font-weight: 700;
    }
    .tile:hover { transform: scale(1.04); }
    .state-unknown { background:#22384f; }
    .state-danger { background:#e74c3c; }
    .state-safe { background:#2ecc71; color:#062012; }
    .hint { outline: 3px solid #59f7b0; box-shadow: 0 0 0 2px rgba(89,247,176,.12); }
    .avoid { outline: 3px solid #ff6b6b; box-shadow: 0 0 0 2px rgba(255,107,107,.10); }
    .heat {
      position:absolute; inset:0; border-radius:16px; opacity:.23; pointer-events:none;
      mix-blend-mode: screen;
    }
    .pill { padding: 8px 10px; border-radius: 999px; border: 1px solid #2a567e; background:#0f1b2a; font-size: 13px; }
    .good { color:#59f7b0; font-weight:700; }
    .bad { color:#ff6b6b; font-weight:700; }
    .warn { color:#ffd166; font-weight:700; }
    table { width:100%; border-collapse: collapse; font-size: 13px; margin-top: 10px; }
    th, td { border-bottom: 1px solid #20364f; padding: 8px; text-align:left; vertical-align: top; }
    .tiny { font-size:12px; opacity:.8; line-height:1.3; }
  </style>
</head>
<body>
  <h1>Grid Detective üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
  <div class="muted">
    Click tiles to mark what you KNOW. The NPC uses your confirmed danger tiles + learned patterns from past cases to recommend the next move and simulate safe paths.
    <br/>Tile cycle: Unknown ‚Üí Danger ‚Üí Safe ‚Üí Unknown
  </div>

  <div class="card">
    <div class="row">
      <label>Difficulty (expected danger tiles): <span id="diffVal" class="warn">8</span></label>
      <input id="difficulty" type="range" min="1" max="24" value="8" />
      <button id="newCase">New Case (clear board)</button>
      <button id="learnCase">End Case + Learn</button>
      <button id="resetAll">Reset Learning</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="pill">Confirmed danger: <b id="cntDanger">0</b></div>
      <div class="pill">Confirmed safe: <b id="cntSafe">0</b></div>
      <div class="pill">Unknown: <b id="cntUnknown">25</b></div>
      <div class="pill">NPC best next: <span class="good" id="bestNext">‚Äî</span></div>
      <div class="pill">Best 3-step path: <span class="good" id="bestPath">‚Äî</span></div>
    </div>

    <div class="tiny" style="margin-top:10px;">
      Heat overlay = how often a tile was marked as danger in past cases. Green outline = best next move. Red outline = ‚Äúavoid‚Äù tile (high learned risk).
    </div>
  </div>

  <div class="gridWrap">
    <div class="grid" id="grid"></div>
  </div>

  <div class="card">
    <div class="row">
      <div class="pill">Cases learned: <b id="cases">0</b></div>
      <div class="pill">Edge danger tendency: <b id="edgeBias">‚Äî</b></div>
      <div class="pill">Corner danger tendency: <b id="cornerBias">‚Äî</b></div>
      <div class="pill">Cluster score: <b id="clusterScore">‚Äî</b></div>
    </div>

    <table>
      <thead>
        <tr>
          <th>Top recommendations</th>
          <th>Estimated risk</th>
          <th>Reasoning (detective notes)</th>
        </tr>
      </thead>
      <tbody id="recTable"></tbody>
    </table>
  </div>

<script>
/* =======================
   Data + Storage
======================= */
const N = 25, W = 5;
const KEY = "grid_detective_truth_v1";

// tile states: 0 unknown, 1 danger, 2 safe
let state = Array(N).fill(0);

function loadLearn() {
  try {
    return JSON.parse(localStorage.getItem(KEY)) ?? {
      cases: 0,
      dangerCounts: Array(N).fill(0), // how many cases each tile was marked danger
      totalDangerMarks: 0,
      layouts: [] // optional: store recent layouts for deeper analysis
    };
  } catch {
    return { cases:0, dangerCounts:Array(N).fill(0), totalDangerMarks:0, layouts:[] };
  }
}
function saveLearn(L) { localStorage.setItem(KEY, JSON.stringify(L)); }

let L = loadLearn();

/* =======================
   Helpers
======================= */
function idxToRC(i){ return {r: Math.floor(i/W), c: i%W}; }
function rcToIdx(r,c){ return r*W+c; }

function neighbors(i){
  const {r,c} = idxToRC(i);
  const deltas = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
  const out = [];
  for (const [dr,dc] of deltas){
    const nr=r+dr, nc=c+dc;
    if(nr>=0&&nr<W&&nc>=0&&nc<W) out.push(rcToIdx(nr,nc));
  }
  return out;
}
function tileGroup(i){
  const {r,c}=idxToRC(i);
  const corner = (r===0||r===4) && (c===0||c===4);
  const edge = (r===0||r===4||c===0||c===4) && !corner;
  const center = (r===2&&c===2);
  return {corner, edge, center};
}
function heatColor(risk){
  const hue = 120*(1-risk); // green->red
  return `hsl(${hue} 95% 55%)`;
}

/* =======================
   UI Build
======================= */
const gridEl = document.getElementById("grid");
const diffEl = document.getElementById("difficulty");
const diffVal = document.getElementById("diffVal");

function buildGrid(){
  gridEl.innerHTML = "";
  for(let i=0;i<N;i++){
    const d = document.createElement("div");
    d.className = "tile state-unknown";
    d.dataset.idx = i;

    const heat = document.createElement("div");
    heat.className = "heat";
    d.appendChild(heat);

    d.addEventListener("click", ()=>cycleTile(i));
    gridEl.appendChild(d);
  }
}

function cycleTile(i){
  state[i] = (state[i] + 1) % 3; // 0->1->2->0
  render();
}

function setTileVisual(tile, i){
  tile.classList.remove("state-unknown","state-danger","state-safe","hint","avoid");
  if(state[i]===0){ tile.classList.add("state-unknown"); tile.textContent=""; }
  if(state[i]===1){ tile.classList.add("state-danger"); tile.textContent="üí£"; }
  if(state[i]===2){ tile.classList.add("state-safe"); tile.textContent="‚úì"; }
}

function renderCounts(){
  const cntDanger = state.filter(x=>x===1).length;
  const cntSafe = state.filter(x=>x===2).length;
  const cntUnknown = N - cntDanger - cntSafe;
  document.getElementById("cntDanger").textContent = cntDanger;
  document.getElementById("cntSafe").textContent = cntSafe;
  document.getElementById("cntUnknown").textContent = cntUnknown;
}

/* =======================
   Smarter NPC Logic
   (User-revealed bombs + learned priors)
======================= */

/*
We compute an "estimated danger risk" for every tile using:
1) Hard constraints: confirmed danger = risk 1.0, confirmed safe = risk 0.0
2) Learned prior: how often tile was marked danger in past cases
3) Difficulty prior: expected danger density sets baseline risk
4) Spatial inference: danger clusters -> neighbors get boosted
5) Consistency correction: if player already marked many bombs this case, remaining tiles get lowered risk (because total bombs expected is limited)
*/

function computeRisk(){
  const expectedDangers = Number(diffEl.value);
  const density = expectedDangers / N; // baseline risk
  const cases = Math.max(1, L.cases);

  // Learned per-tile rate
  const learned = L.dangerCounts.map(c => c / cases);

  // Count current case marks
  const curDanger = state.filter(x=>x===1).length;
  const curSafe = state.filter(x=>x===2).length;
  const curUnknownIdx = state.map((v,i)=>v===0?i:null).filter(v=>v!==null);

  // Remaining bomb budget assumption (soft)
  const remainingBudget = Math.max(0, expectedDangers - curDanger);
  const remainingUnknown = Math.max(1, curUnknownIdx.length);
  const budgetRate = remainingBudget / remainingUnknown;

  const risk = Array(N).fill(0);

  for(let i=0;i<N;i++){
    if(state[i]===1){ risk[i]=1.0; continue; }
    if(state[i]===2){ risk[i]=0.0; continue; }

    // start from blend of baseline + learned
    let r = 0.55*density + 0.45*learned[i];

    // adjust using remaining budget (if you've already found many bombs, unknowns become safer)
    r = 0.55*r + 0.45*budgetRate;

    // spatial: if adjacent tiles are confirmed danger, increase risk slightly (cluster assumption)
    const ns = neighbors(i);
    const neighDanger = ns.filter(j=>state[j]===1).length;
    if(neighDanger>0){
      r += 0.06 * neighDanger; // bump per dangerous neighbor
    }

    // spatial: if adjacent tiles are confirmed safe, reduce risk slightly
    const neighSafe = ns.filter(j=>state[j]===2).length;
    if(neighSafe>0){
      r -= 0.03 * neighSafe;
    }

    // clamp
    r = Math.max(0.01, Math.min(0.99, r));
    risk[i]=r;
  }

  return { risk, learned, density, budgetRate };
}

function recommend(){
  const tiles = document.querySelectorAll(".tile");
  const { risk, learned, density, budgetRate } = computeRisk();

  // Apply heat overlay from learned rates (not current risk) to show long-term patterns
  const cases = Math.max(1, L.cases);
  tiles.forEach((t)=>{
    const i = Number(t.dataset.idx);
    const heat = t.querySelector(".heat");
    const lr = L.dangerCounts[i] / cases;
    heat.style.background = heatColor(lr);
  });

  // Choose best next: lowest risk among unknown tiles
  const unknown = state.map((v,i)=>v===0?i:null).filter(v=>v!==null);
  let best = null, worst = null;
  if(unknown.length){
    best = unknown.reduce((a,b)=> risk[a] < risk[b] ? a : b);
    worst = unknown.reduce((a,b)=> risk[a] > risk[b] ? a : b);
  }

  // Clear hints
  tiles.forEach(t=>t.classList.remove("hint","avoid"));
  if(best!=null) tiles[best].classList.add("hint");
  if(worst!=null) tiles[worst].classList.add("avoid");

  document.getElementById("bestNext").textContent = best==null ? "‚Äî" : String(best);

  // Best 3-step path:
  // Pick 3 lowest-risk unknown tiles, but penalize adjacency to confirmed danger (path safety)
  const scored = unknown.map(i=>{
    const neighDanger = neighbors(i).filter(j=>state[j]===1).length;
    const score = risk[i] + 0.04*neighDanger;
    return {i, score, r:risk[i], neighDanger};
  }).sort((a,b)=>a.score-b.score);

  const path = scored.slice(0,3).map(x=>x.i);
  document.getElementById("bestPath").textContent = path.length ? path.join(" ‚Üí ") : "‚Äî";

  // Table: show top 5 recommendations with reasons
  const tbody = document.getElementById("recTable");
  tbody.innerHTML = "";

  scored.slice(0,5).forEach((x,idx)=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td><b>#${idx+1}</b> tile <b>${x.i}</b></td>
      <td>${(x.r*100).toFixed(1)}%</td>
      <td class="tiny">
        Blend: baseline ${(density*100).toFixed(1)}% ¬∑ learned ${(learned[x.i]*100).toFixed(1)}% ¬∑ budget ${(budgetRate*100).toFixed(1)}% ¬∑
        + neighbor danger penalty (${x.neighDanger})
      </td>
    `;
    tbody.appendChild(tr);
  });

  // Pattern analytics (based on learned layouts)
  document.getElementById("cases").textContent = L.cases;

  // edge/corner bias from learned counts
  const cases2 = Math.max(1, L.cases);
  let edgeSum=0, edgeN=0, cornerSum=0, cornerN=0;
  for(let i=0;i<N;i++){
    const g = tileGroup(i);
    if(g.edge){ edgeSum += L.dangerCounts[i]; edgeN++; }
    if(g.corner){ cornerSum += L.dangerCounts[i]; cornerN++; }
  }
  const edgeRate = (edgeSum/(edgeN*cases2));
  const cornerRate = (cornerSum/(cornerN*cases2));
  document.getElementById("edgeBias").textContent = (edgeRate*100).toFixed(1) + "%";
  document.getElementById("cornerBias").textContent = (cornerRate*100).toFixed(1) + "%";

  // cluster score: average number of dangerous neighbors per dangerous tile in learned layouts (approx)
  // We'll approximate using learned rates: higher neighbor correlations -> higher cluster score.
  let cluster=0, clusterDen=0;
  for(let i=0;i<N;i++){
    const p = L.dangerCounts[i]/cases2;
    const ns = neighbors(i);
    const neighAvg = ns.reduce((acc,j)=>acc + (L.dangerCounts[j]/cases2),0)/ns.length;
    cluster += p*neighAvg;
    clusterDen += p;
  }
  const clusterScore = clusterDen>0 ? (cluster/clusterDen) : 0;
  document.getElementById("clusterScore").textContent = (clusterScore*100).toFixed(1) + "%";
}

function render(){
  diffVal.textContent = diffEl.value;
  const tiles = document.querySelectorAll(".tile");
  tiles.forEach(t=>{
    const i = Number(t.dataset.idx);
    setTileVisual(t,i);
  });
  renderCounts();
  recommend();
}

/* =======================
   Learning: user ends case
======================= */
function endCaseLearn(){
  // We treat "Danger" marks as truth for this case
  const dangerIdx = state.map((v,i)=>v===1?i:null).filter(v=>v!==null);

  // update global learning
  L.cases += 1;
  dangerIdx.forEach(i=>{
    L.dangerCounts[i] += 1;
    L.totalDangerMarks += 1;
  });

  // optionally store last 50 layouts
  const layout = state.map(v=>v===1?1:0);
  L.layouts.unshift(layout);
  if(L.layouts.length > 50) L.layouts.pop();

  saveLearn(L);
  L = loadLearn(); // refresh
  // keep board as-is (so user sees what was learned), but update overlays
  render();
}

function newCase(){
  state = Array(N).fill(0);
  render();
}

function resetLearning(){
  localStorage.removeItem(KEY);
  L = loadLearn();
  state = Array(N).fill(0);
  render();
}

/* =======================
   Wire up
======================= */
buildGrid();
document.getElementById("newCase").addEventListener("click", newCase);
document.getElementById("learnCase").addEventListener("click", endCaseLearn);
document.getElementById("resetAll").addEventListener("click", resetLearning);
diffEl.addEventListener("input", ()=>render());

render();
</script>
</body>
</html>