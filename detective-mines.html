<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Detective Mines üïµÔ∏èüí£</title>
  <style>
    :root{
      --bg:#0b1520; --panel:#0f2232; --panel2:#102a3f; --text:#eaf2ff; --muted:#a9b6c9;
      --tile:#1f3446; --tileBorder:rgba(255,255,255,.08);
      --good:#29d391; --bad:#ff4d4d; --accent:#6aa6ff;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial; background:radial-gradient(1200px 600px at 50% -20%, #1a3d5b 0%, var(--bg) 55%); color:var(--text)}
    .wrap{max-width:980px; margin:0 auto; padding:18px 14px 28px}
    .top{display:flex; gap:12px; flex-wrap:wrap; align-items:stretch}
    .card{background:linear-gradient(180deg,var(--panel),#0c1b28); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .title{display:flex; align-items:center; justify-content:space-between; gap:10px}
    h1{font-size:18px; margin:0; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px; margin-top:6px; line-height:1.35}

    .controls{display:grid; grid-template-columns:1fr; gap:12px; min-width:min(440px,100%)}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    .pill{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-radius:999px; padding:6px 10px; font-size:12px; color:var(--muted)}
    label{font-size:12px; color:var(--muted)}
    input[type=range]{width:220px}
    select{background:rgba(255,255,255,.06); color:var(--text); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px 10px; outline:none}

    .btns{display:flex; gap:10px; flex-wrap:wrap}
    button{border:0; border-radius:12px; padding:10px 12px; font-weight:800; cursor:pointer; color:var(--text); background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.10)}
    button:hover{background:rgba(255,255,255,.12)}
    button.primary{background:linear-gradient(180deg,#2a6dff,#1a4fd6)}
    button.danger{background:linear-gradient(180deg,#ff4d4d,#d93a3a)}
    button.ghost{background:transparent}
    button:disabled{opacity:.45; cursor:not-allowed}

    .hud{display:grid; grid-template-columns:repeat(4, minmax(0,1fr)); gap:10px; margin-top:12px}
    .stat{background:linear-gradient(180deg,var(--panel2),rgba(16,42,63,.35)); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:10px}
    .k{font-size:11px; color:var(--muted)}
    .v{font-size:18px; font-weight:900; margin-top:4px}
    .hint{font-size:12px; color:var(--muted); margin-top:6px; line-height:1.35}

    .main{display:grid; grid-template-columns: minmax(0,1fr) minmax(0,1fr); gap:12px; margin-top:12px}
    @media (max-width:880px){.main{grid-template-columns:1fr}}

    .board{display:grid; grid-template-columns:repeat(5, minmax(0,1fr)); gap:10px; padding:12px}
    .tile{aspect-ratio:1/1; border-radius:16px; background:linear-gradient(180deg,var(--tile),#152636);
      border:1px solid var(--tileBorder); display:flex; align-items:center; justify-content:center;
      position:relative; user-select:none; -webkit-tap-highlight-color:transparent;
      transition:transform .08s ease, box-shadow .18s ease, outline-color .18s ease;
      font-size:22px; font-weight:900}
    .tile:active{transform:scale(.985)}
    .tile.revealed{background:linear-gradient(180deg,#143045,#0e2131)}
    .tile.safe{box-shadow:0 0 0 2px rgba(41,211,145,.25) inset}
    .tile.bomb{box-shadow:0 0 0 2px rgba(255,77,77,.22) inset}
    .tile.labeling{outline:2px dashed rgba(106,166,255,.70); outline-offset:2px}

    .heat{position:absolute; inset:0; border-radius:16px; opacity:0; transition:opacity .18s ease}
    .tile.showHeat .heat{opacity:.92}

    .badge{position:absolute; top:8px; left:8px; font-size:10px; color:rgba(255,255,255,.75); background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12); padding:3px 6px; border-radius:999px}

    .rec{position:absolute; inset:-2px; border-radius:18px; border:2px solid rgba(106,166,255,0);
      box-shadow:0 0 0 rgba(106,166,255,0); transition:all .18s ease}
    .tile.recommended .rec{border-color:rgba(106,166,255,.85); box-shadow:0 0 18px rgba(106,166,255,.20)}
    .tile.backup .rec{border-color:rgba(106,166,255,.35)}

    .panel{padding:14px}
    .npcLine{display:flex; gap:10px; align-items:flex-start}
    .npcIcon{width:34px; height:34px; border-radius:12px; background:linear-gradient(180deg,#2b88ff,#1a4fd6); display:flex; align-items:center; justify-content:center; font-weight:900}
    .npcText{flex:1}
    .npcText .big{font-weight:900; font-size:14px; margin:0}
    .npcText .small{margin:6px 0 0; color:var(--muted); font-size:12px; line-height:1.4}

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px}
    @media (max-width:520px){.grid2{grid-template-columns:1fr}}

    .mini{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.07); border-radius:14px; padding:10px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}

    .history{max-height:220px; overflow:auto; margin-top:10px; padding-right:4px}
    .hitem{display:flex; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px dashed rgba(255,255,255,.10)}
    .hitem:last-child{border-bottom:0}
    .tag{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14); color:rgba(255,255,255,.82)}
    .tag.win{background:rgba(41,211,145,.14); border-color:rgba(41,211,145,.24)}
    .tag.lose{background:rgba(255,77,77,.12); border-color:rgba(255,77,77,.22)}

    .toast{position:fixed; left:50%; bottom:14px; transform:translateX(-50%); background:rgba(10,20,30,.92);
      border:1px solid rgba(255,255,255,.12); color:var(--text); padding:10px 12px; border-radius:12px; display:none;
      max-width:min(680px, calc(100% - 20px)); box-shadow:0 10px 30px rgba(0,0,0,.35); font-size:13px}
    .toast.show{display:block}
  </style>
</head>
<body>
  <div class="wrap">

    <div class="top">
      <div class="card controls" style="flex:1">
        <div class="title">
          <div>
            <h1>Detective Mines üïµÔ∏èüí£</h1>
            <div class="sub">Nova shows predictions first. After the round, <b>you label a mine tile</b> so she learns. Heatmap blends ‚Äúcase pool‚Äù inference + your training memory.</div>
          </div>
          <div class="pill mono" id="seedPill">case: ‚Äî ‚Ä¢ round: ‚Äî</div>
        </div>

        <div class="row" style="margin-top:10px">
          <label>Mines: <b id="mineLabel">8</b></label>
          <input id="mineSlider" type="range" min="1" max="24" value="8" />
          <label>Risk: <b id="riskLabel">55</b></label>
          <input id="riskSlider" type="range" min="0" max="100" value="55" />
        </div>

        <div class="row">
          <label>Case Mode</label>
          <select id="modeSelect">
            <option value="session">Session (more variety)</option>
            <option value="daily">Daily Case (same all day)</option>
          </select>
          <label><input type="checkbox" id="heatToggle" checked /> Heatmap</label>
          <label><input type="checkbox" id="autoSuggest" checked /> Auto-suggest</label>
          <label><input type="checkbox" id="trainMode" checked /> Training Mode</label>
        </div>

        <div class="btns">
          <button class="primary" id="startBtn">Start Round</button>
          <button class="danger" id="cashBtn" disabled>Cash Out</button>
          <button class="ghost" id="revealAllBtn" disabled title="Demo / debug">Reveal Board</button>
          <button class="ghost" id="resetTrainBtn" title="Clears local training memory">Reset Training</button>
        </div>

        <div class="hud">
          <div class="stat"><div class="k">Multiplier</div><div class="v" id="mult">1.00x</div><div class="hint">Safe reveals increase this. Bomb = 0.</div></div>
          <div class="stat"><div class="k">Pattern Locked</div><div class="v" id="lock">0.0%</div><div class="hint">Case pool certainty based on eliminated cases.</div></div>
          <div class="stat"><div class="k">Candidates Left</div><div class="v" id="cand">256</div><div class="hint">Nova narrows these after each safe reveal.</div></div>
          <div class="stat"><div class="k">Best Next Move</div><div class="v" id="best">‚Äî</div><div class="hint">Based on blended heatmap + EV + anti-loop.</div></div>
        </div>
      </div>

      <div class="card" style="flex:1; min-width:min(420px,100%)">
        <div class="npcLine">
          <div class="npcIcon">N</div>
          <div class="npcText">
            <p class="big" id="npcBig">Nova: Ready when you are.</p>
            <p class="small" id="npcSmall">Start a round and I‚Äôll show my prediction immediately. Then you‚Äôll teach me by labeling a mine after the round. üß†</p>
          </div>
        </div>

        <div class="grid2">
          <div class="mini">
            <div class="k">Cashout Advice</div>
            <div class="v" id="cashAdvice">‚Äî</div>
            <div class="hint" id="cashHint">Compares EV of clicking best tile vs locking in now.</div>
          </div>
          <div class="mini">
            <div class="k">Prediction Snapshot</div>
            <div class="v" id="predList">‚Äî</div>
            <div class="hint">Top ‚Äúlikely mines‚Äù (from Nova‚Äôs blended model).</div>
          </div>
        </div>

        <div class="mini" id="trainPanel" style="margin-top:10px; display:none;">
          <div class="k">Train Nova</div>
          <div class="v">Tap ONE tile that was a üí£ mine</div>
          <div class="hint" id="trainHint">Your label is saved locally and improves future predictions.</div>
        </div>

        <div class="mini" style="margin-top:10px">
          <div class="k">History (local)</div>
          <div class="history" id="history"></div>
        </div>
      </div>
    </div>

    <div class="main">
      <div class="card board" id="board"></div>

      <div class="card panel">
        <div style="font-weight:900">How it learns</div>
        <div class="sub" style="margin-top:6px">
          Nova‚Äôs heatmap is a blend: <b>(A)</b> case-pool inference + <b>(B)</b> your labeled mine tiles.
          The more you label, the more the learned model influences predictions.
        </div>

        <div class="mini" style="margin-top:10px">
          <div class="k">Training Notes</div>
          <div class="hint">
            ‚Ä¢ After every round (cashout or boom), Nova asks you to label <b>one mine tile</b>.<br>
            ‚Ä¢ Labels are stored in <span class="mono">localStorage</span> on your device.<br>
            ‚Ä¢ Use ‚ÄúReset Training‚Äù if you want a clean slate.
          </div>
        </div>
      </div>
    </div>

  </div>

  <div class="toast" id="toast"></div>

  <script>
    /**************
     * Core config
     **************/
    const NUM_CASES = 256;
    const CASE_SEEDS = Array.from({length: NUM_CASES}, (_, i) => (i * 2654435761) >>> 0);

    const TILE_COUNT = 25;
    const GRID = 5;

    // tiny EV dampener for balance
    const HOUSE_EDGE = 0.02;

    const TRAIN_KEY = "detective_mines_training_v1";
    const HISTORY_KEY = "detective_mines_history_v1";

    const $ = (id) => document.getElementById(id);

    /*********************
     * Deterministic RNG
     *********************/
    function hash32(...values){
      let h = 2166136261 >>> 0;
      for(const v of values){
        h ^= (v >>> 0);
        h = Math.imul(h, 16777619) >>> 0;
      }
      return h >>> 0;
    }

    function seededShuffle(arr, seed){
      const out = arr.slice();
      let s = seed >>> 0;
      for(let i = out.length - 1; i > 0; i--){
        s = hash32(s, i);
        const j = s % (i + 1);
        const t = out[i]; out[i] = out[j]; out[j] = t;
      }
      return out;
    }

    function dayStamp(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}`;
    }

    /*********************
     * State
     *********************/
    let state = {
      running:false,
      bombCount:8,
      risk:55,
      roundIndex:1,
      caseId:0,
      bombs:new Set(),
      revealed:new Set(),
      safe:new Set(),
      exploded:false,
      multiplier:1,
      candidates:[],
      lastRecs:[],
      awaitingMineLabel:false,
      history:[]
    };

    // training: { [mineCount]: { tileCounts:[25], total:number } }
    let training = {};

    function loadLocal(){
      try{
        const h = localStorage.getItem(HISTORY_KEY);
        if(h) state.history = JSON.parse(h);
      }catch(e){}
      try{
        const t = localStorage.getItem(TRAIN_KEY);
        if(t) training = JSON.parse(t);
      }catch(e){}
    }

    function saveHistory(){
      try{
        localStorage.setItem(HISTORY_KEY, JSON.stringify(state.history.slice(0,60)));
      }catch(e){}
    }

    function saveTraining(){
      try{
        localStorage.setItem(TRAIN_KEY, JSON.stringify(training));
      }catch(e){}
    }

    /*********************
     * Training helpers
     *********************/
    function getTrainingBucket(mineCount){
      const key = String(mineCount);
      if(!training[key]){
        training[key] = { tileCounts: Array(25).fill(0), total: 0 };
      }
      return training[key];
    }

    function trainingProbs(mineCount){
      const b = getTrainingBucket(mineCount);
      // Laplace smoothing to avoid overconfidence early
      const smooth = 1;
      const denom = b.total + smooth * 25;
      return b.tileCounts.map(c => (c + smooth) / denom);
    }

    function blendedProbs(caseProbs, mineCount){
      const learned = trainingProbs(mineCount);
      const b = getTrainingBucket(mineCount);
      // As labels increase, rely more on learned data (max 55%)
      const learnStrength = Math.min(0.55, b.total / 40);
      const alpha = 1 - learnStrength; // weight on case model

      const out = [];
      for(let i=0;i<25;i++){
        out[i] = (caseProbs[i] * alpha) + (learned[i] * (1 - alpha));
      }
      return out;
    }

    /*********************
     * Board generation
     *********************/
    function generateBoard(caseId, bombCount, roundIndex){
      const baseSeed = CASE_SEEDS[caseId];
      const seed = hash32(baseSeed, bombCount, roundIndex);
      const tiles = Array.from({length:TILE_COUNT}, (_,i)=>i);
      const shuffled = seededShuffle(tiles, seed);
      return new Set(shuffled.slice(0, bombCount));
    }

    function pickCaseId(mode, bombCount, roundIndex){
      if(mode === 'daily'){
        const ds = dayStamp();
        let acc = 0;
        for(let i=0;i<ds.length;i++) acc = hash32(acc, ds.charCodeAt(i));
        return (hash32(acc, bombCount, roundIndex) % NUM_CASES) >>> 0;
      }
      const r = (Math.random() * 1e9) >>> 0;
      return (hash32(r, bombCount, roundIndex) % NUM_CASES) >>> 0;
    }

    /*********************
     * NPC elimination
     *********************/
    function resetNPC(){
      state.candidates = Array.from({length:NUM_CASES}, (_,i)=>i);
      state.lastRecs = [];
    }

    function eliminateCases(){
      const safeTiles = state.safe;
      const bombCount = state.bombCount;
      const roundIndex = state.roundIndex;

      state.candidates = state.candidates.filter(caseId => {
        const layout = generateBoard(caseId, bombCount, roundIndex);
        for(const t of safeTiles){
          if(layout.has(t)) return false;
        }
        return true;
      });

      if(state.candidates.length === 0){
        resetNPC();
      }
    }

    function heatmapCaseProbs(){
      const probs = Array(TILE_COUNT).fill(0);
      const cand = state.candidates;
      const bombCount = state.bombCount;
      const roundIndex = state.roundIndex;

      for(const caseId of cand){
        const layout = generateBoard(caseId, bombCount, roundIndex);
        for(let i=0;i<TILE_COUNT;i++){
          if(layout.has(i)) probs[i] += 1;
        }
      }
      const denom = cand.length || 1;
      for(let i=0;i<TILE_COUNT;i++) probs[i] = probs[i] / denom;
      return probs;
    }

    /*********************
     * Multiplier curve
     *********************/
    function nextMultiplier(current, bombCount, revealedSafeCount){
      const danger = bombCount / TILE_COUNT;
      const baseGain = 0.045 + 0.22 * danger;
      const streakBonus = Math.min(0.08, revealedSafeCount * 0.006);
      const gain = baseGain + streakBonus;
      return Math.max(1.0, current * (1 + gain));
    }

    /*********************
     * EV + move selection
     *********************/
    function formatTile(i){
      const r = Math.floor(i / GRID) + 1;
      const c = (i % GRID) + 1;
      return `R${r}C${c}`;
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    function recommendMoves(probs){
      const revealed = state.revealed;
      const bombCount = state.bombCount;
      const safeCount = state.safe.size;

      const scored = [];
      for(let i=0;i<TILE_COUNT;i++){
        if(revealed.has(i)) continue;

        const pBomb = probs[i];
        const pSafe = 1 - pBomb;

        const mNext = nextMultiplier(state.multiplier, bombCount, safeCount);

        let ev = (pSafe * mNext);
        ev *= (1 - HOUSE_EDGE);

        // anti-loop
        const recentIndex = state.lastRecs.lastIndexOf(i);
        if(recentIndex !== -1){
          const age = (state.lastRecs.length - 1) - recentIndex;
          const penalty = 0.08 * (1 / (age + 1));
          ev *= (1 - penalty);
        }

        // subtle variety bias
        const centerBias = 1 - (Math.abs((i%5)-2) + Math.abs(Math.floor(i/5)-2)) * 0.015;
        ev *= centerBias;

        scored.push({i, ev, pBomb});
      }

      scored.sort((a,b)=>b.ev - a.ev);
      return {best: scored[0] || null, backups: scored.slice(1,3), scored};
    }

    function cashoutAdvice(best){
      if(!state.running || state.exploded) return {text:"‚Äî", hint:""};

      const risk = state.risk / 100;
      const cashEV = state.multiplier;

      if(!best){
        return {text:"Cash out ‚úÖ", hint:"No candidates to recommend."};
      }

      const contEV = best.ev;
      const margin = 0.02 + (0.10 * (1 - risk)); // safe => cash earlier

      if(cashEV >= contEV * (1 - margin)){
        return {text:`Cash out now ‚úÖ`, hint:`Locking ${cashEV.toFixed(2)}x is safer than clicking (${contEV.toFixed(2)}x EV).`};
      }
      return {text:`Keep going üî•`, hint:`Best click EV (${contEV.toFixed(2)}x) edges out cashout (${cashEV.toFixed(2)}x).`};
    }

    /*********************
     * UI helpers
     *********************/
    function toast(msg){
      const t = $("toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toast._tm);
      toast._tm = setTimeout(()=>t.classList.remove("show"), 2200);
    }

    function heatColor(pBomb){
      const p = clamp01(pBomb);
      const r = Math.round(40 + 215 * p);
      const g = Math.round(200 - 170 * p);
      const b = Math.round(80 - 60 * p);
      return `rgba(${r},${g},${b},0.45)`;
    }

    function clearRecommendations(){
      for(let i=0;i<TILE_COUNT;i++){
        $("tile-"+i)?.classList.remove("recommended","backup");
      }
    }

    function applyHeatmap(probs){
      const show = $("heatToggle").checked;
      for(let i=0;i<TILE_COUNT;i++){
        const tile = $("tile-"+i);
        if(!tile) continue;
        const heat = tile.querySelector(".heat");
        const badge = tile.querySelector(".badge");
        if(!heat || !badge) continue;

        const hidden = state.revealed.has(i);

        if(show && !hidden){
          tile.classList.add("showHeat");
          heat.style.background = `radial-gradient(120px 120px at 50% 50%, ${heatColor(probs[i])} 0%, rgba(0,0,0,0) 65%)`;
          badge.textContent = `${Math.round(probs[i]*100)}%`;
        }else{
          tile.classList.remove("showHeat");
          heat.style.background = "transparent";
          badge.textContent = "";
        }
      }
    }

    function setTileFace(i, emoji, cls){
      const tile = $("tile-"+i);
      if(!tile) return;
      tile.classList.add("revealed");
      if(cls) tile.classList.add(cls);
      tile.querySelector(".face").textContent = emoji;
      tile.querySelector(".badge").textContent = "";
      tile.classList.remove("showHeat");
    }

    function renderBoard(){
      const board = $("board");
      board.innerHTML = "";
      for(let i=0;i<TILE_COUNT;i++){
        const div = document.createElement("div");
        div.className = "tile";
        div.id = "tile-"+i;
        div.innerHTML = `<div class="heat"></div><div class="rec"></div><div class="badge"></div><div class="face"></div>`;
        div.addEventListener("click", ()=>onTile(i));
        board.appendChild(div);
      }
    }

    function renderHistory(){
      const el = $("history");
      const h = state.history.slice(0,20);
      if(h.length === 0){
        el.innerHTML = `<div class="hint">No rounds yet. Nova is waiting. üò∂</div>`;
        return;
      }
      el.innerHTML = h.map(item=>{
        const tag = item.result === "WIN"
          ? `<span class="tag win">WIN</span>`
          : `<span class="tag lose">LOSE</span>`;
        return `
          <div class="hitem">
            <div>
              <div style="font-weight:900">${tag} <span class="mono">m=${item.mines}</span> ‚Ä¢ <span class="mono">r=${item.round}</span></div>
              <div class="hint">safe=${item.safe} ‚Ä¢ locked=${item.locked.toFixed(1)}% ‚Ä¢ labels=${item.labels}</div>
            </div>
            <div style="text-align:right">
              <div style="font-weight:900">${item.mult.toFixed(2)}x</div>
              <div class="hint">${item.when}</div>
            </div>
          </div>
        `;
      }).join("");
    }

    function updatePredSnapshot(probs){
      const unrevealed = [];
      for(let i=0;i<TILE_COUNT;i++){
        if(state.revealed.has(i)) continue;
        unrevealed.push({i, p: probs[i]});
      }
      unrevealed.sort((a,b)=>b.p - a.p);
      const top = unrevealed.slice(0,3).map(x=>`${formatTile(x.i)} (${Math.round(x.p*100)}%)`).join(" ‚Ä¢ ");
      $("predList").textContent = top || "‚Äî";
    }

    function updateHUD(recs, probs){
      $("mult").textContent = `${state.multiplier.toFixed(2)}x`;

      const locked = 100 * (1 - (state.candidates.length / NUM_CASES));
      $("lock").textContent = `${locked.toFixed(1)}%`;
      $("cand").textContent = `${state.candidates.length}`;

      const pill = `case: ${state.running ? state.caseId : "‚Äî"} ‚Ä¢ round: ${state.running ? state.roundIndex : "‚Äî"}`;
      $("seedPill").textContent = pill;

      updatePredSnapshot(probs);

      if(!state.running){
        $("best").textContent = "‚Äî";
        $("cashAdvice").textContent = "‚Äî";
        $("cashHint").textContent = "Compares EV of clicking best tile vs locking in now.";
        return;
      }

      if(recs?.best){
        $("best").textContent = `${formatTile(recs.best.i)} (${Math.round((1-recs.best.pBomb)*100)}% safe)`;
      }else{
        $("best").textContent = "‚Äî";
      }

      const advice = cashoutAdvice(recs?.best);
      $("cashAdvice").textContent = advice.text;
      $("cashHint").textContent = advice.hint || $("cashHint").textContent;

      // NPC voice
      if(state.awaitingMineLabel){
        $("npcBig").textContent = "Nova: Teach me. üß†";
        $("npcSmall").textContent = "Tap ONE tile that was a mine. I‚Äôll remember it for this mine-count.";
        return;
      }

      if(state.exploded){
        $("npcBig").textContent = "Nova: Boom. Case closed. üí£";
        $("npcSmall").textContent = "Start another round and label a mine so I learn faster next time.";
      }else{
        if(recs?.best){
          $("npcBig").textContent = `Nova: Prediction first ‚Äî then tap ${formatTile(recs.best.i)}.`;
          $("npcSmall").textContent = `Top mine suspects are listed on the right. Your risk dial is ${state.risk}‚Ä¶ so I‚Äôm ${state.risk<40?"playing it safe":"feeling spicy"}.`;
        }else{
          $("npcBig").textContent = "Nova: Start the round and I‚Äôll show my prediction.";
          $("npcSmall").textContent = "Heatmap + suspects list will appear instantly.";
        }
      }

      applyHeatmap(probs);

      clearRecommendations();
      if($("autoSuggest").checked && recs?.best){
        $("tile-"+recs.best.i)?.classList.add("recommended");
        for(const b of recs.backups || []){
          $("tile-"+b.i)?.classList.add("backup");
        }
      }
    }

    /*********************
     * Game actions
     *********************/
    function computeProbs(){
      let probs = heatmapCaseProbs();
      if($("trainMode").checked){
        probs = blendedProbs(probs, state.bombCount);
      }
      return probs;
    }

    function startRound(){
      state.running = true;
      state.exploded = false;
      state.awaitingMineLabel = false;

      state.revealed = new Set();
      state.safe = new Set();
      state.multiplier = 1;

      state.bombCount = parseInt($("mineSlider").value, 10);
      state.risk = parseInt($("riskSlider").value, 10);

      const mode = $("modeSelect").value;
      state.caseId = pickCaseId(mode, state.bombCount, state.roundIndex);
      state.bombs = generateBoard(state.caseId, state.bombCount, state.roundIndex);

      resetNPC();
      renderBoard();

      $("trainPanel").style.display = "none";
      $("cashBtn").disabled = false;
      $("revealAllBtn").disabled = false;

      // SHOW prediction immediately (before user clicks)
      const probs = computeProbs();
      const recs = recommendMoves(probs);
      updateHUD(recs, probs);

      toast("Prediction is up. Your move. üïµÔ∏è");
    }

    function beginMineLabeling(){
      if(!$("trainMode").checked) return;
      state.awaitingMineLabel = true;
      $("trainPanel").style.display = "block";
      $("trainHint").textContent = "Tap ONE tile that was a mine üí£. This is saved locally and improves future predictions.";

      for(let i=0;i<TILE_COUNT;i++){
        $("tile-"+i)?.classList.add("labeling");
      }
    }

    function stopMineLabeling(){
      state.awaitingMineLabel = false;
      $("trainPanel").style.display = "none";
      for(let i=0;i<TILE_COUNT;i++){
        $("tile-"+i)?.classList.remove("labeling");
      }
    }

    function endRound(result){
      const locked = 100 * (1 - (state.candidates.length / NUM_CASES));
      const labels = getTrainingBucket(state.bombCount).total;

      const now = new Date();
      const when = now.toLocaleString([], {month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit"});

      state.history.unshift({
        result,
        mines: state.bombCount,
        round: state.roundIndex,
        safe: state.safe.size,
        mult: state.multiplier,
        locked,
        labels,
        when
      });
      state.history = state.history.slice(0,60);
      saveHistory();
      renderHistory();

      $("cashBtn").disabled = true;
      $("revealAllBtn").disabled = true;

      // stop gameplay, then ask for labeling
      state.running = false;
      beginMineLabeling();

      // increment for next round start
      state.roundIndex += 1;

      const probs = computeProbs();
      updateHUD(null, probs);
    }

    function cashOut(){
      if(!state.running || state.exploded) return;
      toast(`Cashed out at ${state.multiplier.toFixed(2)}x ‚úÖ`);
      $("npcBig").textContent = "Nova: Clean exit.";
      $("npcSmall").textContent = "Now label a mine so I get smarter.";
      endRound("WIN");
    }

    function revealAll(){
      if(!state.running) return;
      for(let i=0;i<TILE_COUNT;i++){
        if(state.revealed.has(i)) continue;
        if(state.bombs.has(i)) setTileFace(i,"üí£","bomb");
        else setTileFace(i,"üíé","safe");
      }
      toast("Board revealed.");
    }

    function onTile(i){
      // TRAINING LABEL MODE:
      if(state.awaitingMineLabel){
        const b = getTrainingBucket(state.bombCount);
        b.tileCounts[i] += 1;
        b.total += 1;
        saveTraining();

        stopMineLabeling();
        toast(`Mine recorded at ${formatTile(i)} ‚úÖ Nova learned.`);

        $("npcBig").textContent = "Nova: Noted.";
        $("npcSmall").textContent = "Start the next round. I‚Äôll fold this into my prediction.";

        return;
      }

      // NORMAL PLAY MODE:
      if(!state.running || state.exploded) return;
      if(state.revealed.has(i)) return;

      state.revealed.add(i);

      if(state.bombs.has(i)){
        state.exploded = true;
        setTileFace(i, "üí£", "bomb");

        // show all bombs for clarity
        for(let t=0;t<TILE_COUNT;t++){
          if(!state.revealed.has(t) && state.bombs.has(t)){
            setTileFace(t, "üí£", "bomb");
            state.revealed.add(t);
          }
        }

        toast("Bomb. Round lost. üí•");
        $("npcBig").textContent = "Nova: That tile was cursed.";
        $("npcSmall").textContent = "Label a mine so I can learn the pattern better.";

        endRound("LOSE");
        return;
      }

      // safe
      state.safe.add(i);
      setTileFace(i, "üíé", "safe");

      // multiplier
      state.multiplier = nextMultiplier(state.multiplier, state.bombCount, state.safe.size);

      // case elimination learns from SAFE reveals
      eliminateCases();

      // recompute heatmap + suggestions
      const probs = computeProbs();
      const recs = recommendMoves(probs);

      if(recs?.best){
        state.lastRecs.push(recs.best.i);
        if(state.lastRecs.length > 8) state.lastRecs.shift();
      }

      updateHUD(recs, probs);

      const locked = 100 * (1 - (state.candidates.length / NUM_CASES));
      if(locked >= 95) toast("Pattern locked. Nova sees it. üëÅÔ∏è");
    }

    function resetTraining(){
      training = {};
      saveTraining();
      toast("Training cleared. Fresh brain. üßº");
      // refresh prediction if running
      const probs = computeProbs();
      const recs = recommendMoves(probs);
      updateHUD(recs, probs);
      renderHistory();
    }

    /*********************
     * Wire up controls
     *********************/
    $("mineSlider").addEventListener("input", e=>{
      const v = parseInt(e.target.value, 10);
      $("mineLabel").textContent = v;
    });
    $("riskSlider").addEventListener("input", e=>{
      const v = parseInt(e.target.value, 10);
      $("riskLabel").textContent = v;
      state.risk = v;
      if(state.running){
        const probs = computeProbs();
        const recs = recommendMoves(probs);
        updateHUD(recs, probs);
      }
    });

    $("startBtn").addEventListener("click", startRound);
    $("cashBtn").addEventListener("click", cashOut);
    $("revealAllBtn").addEventListener("click", revealAll);
    $("resetTrainBtn").addEventListener("click", resetTraining);

    // init
    loadLocal();
    renderBoard();
    renderHistory();
    $("mineLabel").textContent = $("mineSlider").value;
    $("riskLabel").textContent = $("riskSlider").value;
    $("cand").textContent = String(NUM_CASES);
    $("lock").textContent = "0.0%";
  </script>
</body>
</html>